package api

import (
	"context"
	"errors"
	"strings"

	"github.com/beaesthetic/consent-service/internal/application"
	"github.com/beaesthetic/consent-service/internal/domain"
)

// Server implements the StrictServerInterface generated by oapi-codegen
type Server struct {
	policyService  *application.PolicyService
	consentService *application.ConsentService
	linkService    *application.LinkService
}

// NewServer creates a new Server instance
func NewServer(
	policyService *application.PolicyService,
	consentService *application.ConsentService,
	linkService *application.LinkService,
) *Server {
	return &Server{
		policyService:  policyService,
		consentService: consentService,
		linkService:    linkService,
	}
}

// Ensure Server implements StrictServerInterface
var _ StrictServerInterface = (*Server)(nil)

// ListPolicies implements StrictServerInterface
func (s *Server) ListPolicies(ctx context.Context, request ListPoliciesRequestObject) (ListPoliciesResponseObject, error) {
	tenantID := request.Params.XTenantID

	var policies []domain.Policy
	var err error

	if request.Params.Active != nil && *request.Params.Active {
		policies, err = s.policyService.GetActivePolicies(tenantID)
	} else {
		policies, err = s.policyService.GetAllPolicies(tenantID)
	}

	if err != nil {
		return ListPolicies500JSONResponse{errResponse(err.Error())}, nil
	}

	apiPolicies := make([]Policy, len(policies))
	for i, p := range policies {
		apiPolicies[i] = domainPolicyToAPI(p)
	}

	return ListPolicies200JSONResponse{Policies: &apiPolicies}, nil
}

// GetPolicy implements StrictServerInterface
func (s *Server) GetPolicy(ctx context.Context, request GetPolicyRequestObject) (GetPolicyResponseObject, error) {
	tenantID := request.Params.XTenantID

	policy, err := s.policyService.GetPolicy(tenantID, request.Slug)
	if err != nil {
		if errors.Is(err, domain.ErrPolicyNotFound) {
			return GetPolicy404JSONResponse{notFoundResponse("policy not found")}, nil
		}
		return GetPolicy500JSONResponse{errResponse(err.Error())}, nil
	}

	apiPolicy := domainPolicyToAPI(*policy)
	return GetPolicy200JSONResponse(apiPolicy), nil
}

// CreatePolicy implements StrictServerInterface
func (s *Server) CreatePolicy(ctx context.Context, request CreatePolicyRequestObject) (CreatePolicyResponseObject, error) {
	tenantID := request.Params.XTenantID

	policy, err := s.policyService.CreatePolicy(tenantID, application.CreatePolicyRequest{
		Slug:        request.Body.Slug,
		Name:        request.Body.Name,
		Description: derefString(request.Body.Description),
	})
	if err != nil {
		if errors.Is(err, domain.ErrPolicyAlreadyExists) {
			return CreatePolicy409JSONResponse(ErrorResponse{Error: ptr("policy already exists")}), nil
		}
		return CreatePolicy500JSONResponse{errResponse(err.Error())}, nil
	}

	apiPolicy := domainPolicyToAPI(*policy)
	return CreatePolicy201JSONResponse(apiPolicy), nil
}

// AddPolicyVersion implements StrictServerInterface
func (s *Server) AddPolicyVersion(ctx context.Context, request AddPolicyVersionRequestObject) (AddPolicyVersionResponseObject, error) {
	tenantID := request.Params.XTenantID

	policy, err := s.policyService.AddVersion(tenantID, request.Slug, application.AddVersionRequest{
		Version:              request.Body.Version,
		ContentHTML:          derefString(request.Body.ContentHtml),
		ContentMarkdown:      derefString(request.Body.ContentMarkdown),
		PDFURL:               derefString(request.Body.PdfUrl),
		IsActive:             derefBool(request.Body.IsActive),
		RequiresReAcceptance: derefBool(request.Body.RequiresReAcceptance),
	})
	if err != nil {
		if errors.Is(err, domain.ErrPolicyNotFound) {
			return AddPolicyVersion404JSONResponse{notFoundResponse("policy not found")}, nil
		}
		if errors.Is(err, domain.ErrVersionAlreadyExists) {
			return AddPolicyVersion409JSONResponse(ErrorResponse{Error: ptr("version already exists")}), nil
		}
		return AddPolicyVersion500JSONResponse{errResponse(err.Error())}, nil
	}

	apiPolicy := domainPolicyToAPI(*policy)
	return AddPolicyVersion201JSONResponse(apiPolicy), nil
}

// GetConsents implements StrictServerInterface
func (s *Server) GetConsents(ctx context.Context, request GetConsentsRequestObject) (GetConsentsResponseObject, error) {
	tenantID := request.Params.XTenantID

	if request.Params.Policy != nil {
		consent, err := s.consentService.GetActiveConsentBySubjectAndPolicy(tenantID, request.Params.Subject, *request.Params.Policy)
		if err != nil {
			if errors.Is(err, domain.ErrConsentNotFound) {
				return GetConsents404JSONResponse{notFoundResponse("consent not found")}, nil
			}
			return GetConsents500JSONResponse{errResponse(err.Error())}, nil
		}
		apiConsent := domainConsentToAPI(*consent)
		return GetConsents200JSONResponse{
			Subject:  ptr(consent.Subject),
			Consents: &[]Consent{apiConsent},
		}, nil
	}

	subjectConsents, err := s.consentService.GetConsentsBySubject(tenantID, request.Params.Subject)
	if err != nil {
		return GetConsents500JSONResponse{errResponse(err.Error())}, nil
	}

	apiConsents := make([]Consent, len(subjectConsents.Consents))
	for i, c := range subjectConsents.Consents {
		apiConsents[i] = domainConsentToAPI(c)
	}

	return GetConsents200JSONResponse{
		Subject:  ptr(subjectConsents.Subject),
		Consents: &apiConsents,
	}, nil
}

// GetConsentById implements StrictServerInterface
func (s *Server) GetConsentById(ctx context.Context, request GetConsentByIdRequestObject) (GetConsentByIdResponseObject, error) {
	consent, err := s.consentService.GetConsentByID(request.Id)
	if err != nil {
		if errors.Is(err, domain.ErrConsentNotFound) {
			return GetConsentById404JSONResponse{notFoundResponse("consent not found")}, nil
		}
		return GetConsentById500JSONResponse{errResponse(err.Error())}, nil
	}

	apiConsent := domainConsentToAPI(*consent)
	return GetConsentById200JSONResponse(apiConsent), nil
}

// CreateConsent implements StrictServerInterface
func (s *Server) CreateConsent(ctx context.Context, request CreateConsentRequestObject) (CreateConsentResponseObject, error) {
	tenantID := request.Params.XTenantID

	policies := make([]application.PolicyConsent, len(request.Body.Policies))
	for i, p := range request.Body.Policies {
		policies[i] = application.PolicyConsent{
			Slug:    p.Slug,
			Version: derefString(p.Version),
		}
	}

	consents, err := s.consentService.CreateConsents(
		tenantID,
		application.CreateConsentRequest{
			Subject:  request.Body.Subject,
			Policies: policies,
		},
		domain.AcceptanceMethodDirect,
		nil,
	)
	if err != nil {
		if errors.Is(err, domain.ErrPolicyNotFound) {
			return CreateConsent404JSONResponse{notFoundResponse("policy not found")}, nil
		}
		if errors.Is(err, domain.ErrNoActiveVersion) {
			return CreateConsent400JSONResponse{badRequestResponse("policy has no active version")}, nil
		}
		return CreateConsent500JSONResponse{errResponse(err.Error())}, nil
	}

	apiConsents := make([]Consent, len(consents))
	for i, c := range consents {
		apiConsents[i] = domainConsentToAPI(c)
	}

	return CreateConsent201JSONResponse{Consents: &apiConsents}, nil
}

// GetConsentStatus implements StrictServerInterface
func (s *Server) GetConsentStatus(ctx context.Context, request GetConsentStatusRequestObject) (GetConsentStatusResponseObject, error) {
	tenantID := request.Params.XTenantID
	subject := request.Params.Subject

	// Parse optional comma-separated slugs
	var slugs []string
	if request.Params.Slugs != nil && *request.Params.Slugs != "" {
		slugs = strings.Split(*request.Params.Slugs, ",")
		for i := range slugs {
			slugs[i] = strings.TrimSpace(slugs[i])
		}
	}

	statuses, err := s.consentService.GetConsentStatus(tenantID, subject, slugs)
	if err != nil {
		if errors.Is(err, domain.ErrInvalidTenantID) || errors.Is(err, domain.ErrInvalidSubject) {
			return GetConsentStatus400JSONResponse{badRequestResponse(err.Error())}, nil
		}
		if errors.Is(err, domain.ErrPolicyNotFound) {
			return GetConsentStatus404JSONResponse{notFoundResponse(err.Error())}, nil
		}
		return GetConsentStatus500JSONResponse{errResponse(err.Error())}, nil
	}

	apiStatuses := make([]PolicyConsentStatus, len(statuses))
	for i, s := range statuses {
		apiStatuses[i] = domainConsentStatusToAPI(s)
	}

	return GetConsentStatus200JSONResponse{
		Subject:  ptr(subject),
		Statuses: &apiStatuses,
	}, nil
}

// RevokeConsent implements StrictServerInterface
func (s *Server) RevokeConsent(ctx context.Context, request RevokeConsentRequestObject) (RevokeConsentResponseObject, error) {
	consent, err := s.consentService.RevokeConsent(request.Id, request.Body.RevokedBy)
	if err != nil {
		if errors.Is(err, domain.ErrConsentNotFound) {
			return RevokeConsent404JSONResponse{notFoundResponse("consent not found")}, nil
		}
		if errors.Is(err, domain.ErrConsentAlreadyRevoked) {
			return RevokeConsent409JSONResponse(ErrorResponse{Error: ptr("consent already revoked")}), nil
		}
		return RevokeConsent500JSONResponse{errResponse(err.Error())}, nil
	}

	apiConsent := domainConsentToAPI(*consent)
	return RevokeConsent200JSONResponse(apiConsent), nil
}

// CreateLink implements StrictServerInterface
func (s *Server) CreateLink(ctx context.Context, request CreateLinkRequestObject) (CreateLinkResponseObject, error) {
	tenantID := request.Params.XTenantID

	response, err := s.linkService.CreateLink(tenantID, application.CreateLinkRequest{
		Subject:        request.Body.Subject,
		Policies:       request.Body.Policies,
		ExpiresInHours: request.Body.ExpiresInHours,
		CreatedBy:      request.Body.CreatedBy,
	})
	if err != nil {
		if errors.Is(err, domain.ErrPolicyNotFound) {
			return CreateLink404JSONResponse{notFoundResponse("one or more policies not found")}, nil
		}
		if errors.Is(err, domain.ErrNoActiveVersion) {
			return CreateLink400JSONResponse{badRequestResponse("one or more policies have no active version")}, nil
		}
		return CreateLink500JSONResponse{errResponse(err.Error())}, nil
	}

	return CreateLink201JSONResponse{
		Token:     ptr(response.Token),
		Url:       ptr(response.URL),
		ExpiresAt: response.ExpiresAt,
	}, nil
}

// GetLinkStatus implements StrictServerInterface
func (s *Server) GetLinkStatus(ctx context.Context, request GetLinkStatusRequestObject) (GetLinkStatusResponseObject, error) {
	link, err := s.linkService.GetLink(request.Token)
	if err != nil {
		if errors.Is(err, domain.ErrLinkNotFound) {
			return GetLinkStatus404JSONResponse{notFoundResponse("link not found")}, nil
		}
		return GetLinkStatus500JSONResponse{errResponse(err.Error())}, nil
	}

	apiLink := domainLinkToAPI(*link)
	return GetLinkStatus200JSONResponse(apiLink), nil
}

// DeleteLink implements StrictServerInterface
func (s *Server) DeleteLink(ctx context.Context, request DeleteLinkRequestObject) (DeleteLinkResponseObject, error) {
	err := s.linkService.InvalidateLink(request.Token)
	if err != nil {
		if errors.Is(err, domain.ErrLinkNotFound) {
			return DeleteLink404JSONResponse{notFoundResponse("link not found")}, nil
		}
		return DeleteLink500JSONResponse{errResponse(err.Error())}, nil
	}

	return DeleteLink204Response{}, nil
}

// GetPublicLinkInfo implements StrictServerInterface
func (s *Server) GetPublicLinkInfo(ctx context.Context, request GetPublicLinkInfoRequestObject) (GetPublicLinkInfoResponseObject, error) {
	linkInfo, err := s.linkService.GetLinkInfo(request.Token)
	if err != nil {
		if errors.Is(err, domain.ErrLinkNotFound) {
			return GetPublicLinkInfo404JSONResponse{notFoundResponse("link not found")}, nil
		}
		if errors.Is(err, domain.ErrLinkExpired) {
			return GetPublicLinkInfo410JSONResponse(ErrorResponse{Error: ptr("link has expired")}), nil
		}
		if errors.Is(err, domain.ErrLinkAlreadyUsed) {
			return GetPublicLinkInfo410JSONResponse(ErrorResponse{Error: ptr("link has already been used")}), nil
		}
		return GetPublicLinkInfo500JSONResponse{errResponse(err.Error())}, nil
	}

	apiPolicies := make([]PublicPolicyInfo, len(linkInfo.Policies))
	for i, p := range linkInfo.Policies {
		apiPolicies[i] = PublicPolicyInfo{
			Slug:            ptr(p.Slug),
			Name:            ptr(p.Name),
			Description:     ptr(p.Description),
			Version:         ptr(p.Version),
			ContentHtml:     ptr(p.ContentHTML),
			ContentMarkdown: ptr(p.ContentMarkdown),
			PdfUrl:          ptr(p.PDFURL),
		}
	}

	return GetPublicLinkInfo200JSONResponse{
		Token:     ptr(linkInfo.Token),
		Subject:   ptr(linkInfo.Subject),
		Policies:  &apiPolicies,
		ExpiresAt: ptr(linkInfo.ExpiresAt),
	}, nil
}

// AcceptConsent implements StrictServerInterface
func (s *Server) AcceptConsent(ctx context.Context, request AcceptConsentRequestObject) (AcceptConsentResponseObject, error) {
	link, err := s.linkService.GetLink(request.Token)
	if err != nil {
		if errors.Is(err, domain.ErrLinkNotFound) {
			return AcceptConsent404JSONResponse{notFoundResponse("link not found")}, nil
		}
		return AcceptConsent500JSONResponse{errResponse(err.Error())}, nil
	}

	if err := link.IsValid(); err != nil {
		if errors.Is(err, domain.ErrLinkExpired) {
			return AcceptConsent410JSONResponse(ErrorResponse{Error: ptr("link has expired")}), nil
		}
		if errors.Is(err, domain.ErrLinkAlreadyUsed) {
			return AcceptConsent410JSONResponse(ErrorResponse{Error: ptr("link has already been used")}), nil
		}
		return AcceptConsent400JSONResponse{badRequestResponse(err.Error())}, nil
	}

	// Validate all accepted policies are in the link
	linkPolicySet := make(map[string]bool)
	for _, slug := range link.Policies {
		linkPolicySet[slug] = true
	}

	for _, slug := range request.Body.AcceptedPolicies {
		if !linkPolicySet[slug] {
			return AcceptConsent400JSONResponse{badRequestResponse("policy " + slug + " is not part of this consent link")}, nil
		}
	}

	// Create consents for accepted policies using the link's tenant
	policies := make([]application.PolicyConsent, len(request.Body.AcceptedPolicies))
	for i, slug := range request.Body.AcceptedPolicies {
		policies[i] = application.PolicyConsent{Slug: slug}
	}

	token := request.Token
	consents, err := s.consentService.CreateConsents(
		link.TenantID,
		application.CreateConsentRequest{
			Subject:  link.Subject,
			Policies: policies,
		},
		domain.AcceptanceMethodLink,
		&token,
	)
	if err != nil {
		return AcceptConsent500JSONResponse{errResponse(err.Error())}, nil
	}

	// Mark link as used
	_ = s.linkService.MarkLinkAsUsed(request.Token)

	apiConsents := make([]Consent, len(consents))
	for i, c := range consents {
		apiConsents[i] = domainConsentToAPI(c)
	}

	return AcceptConsent201JSONResponse{Consents: &apiConsents}, nil
}
