// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// Defines values for ConsentAcceptanceMethod.
const (
	Direct ConsentAcceptanceMethod = "direct"
	Link   ConsentAcceptanceMethod = "link"
)

// Defines values for PolicyConsentStatusStatus.
const (
	Accepted PolicyConsentStatusStatus = "accepted"
	Missing  PolicyConsentStatusStatus = "missing"
	Outdated PolicyConsentStatusStatus = "outdated"
)

// AcceptConsentRequest defines model for AcceptConsentRequest.
type AcceptConsentRequest struct {
	AcceptedPolicies []string `json:"accepted_policies"`
}

// AddVersionRequest defines model for AddVersionRequest.
type AddVersionRequest struct {
	ContentHtml     *string `json:"content_html,omitempty"`
	ContentMarkdown *string `json:"content_markdown,omitempty"`
	IsActive        *bool   `json:"is_active,omitempty"`
	PdfUrl          *string `json:"pdf_url,omitempty"`

	// RequiresReAcceptance Whether this version requires subjects to re-accept their consent
	RequiresReAcceptance *bool  `json:"requires_re_acceptance,omitempty"`
	Version              string `json:"version"`
}

// Consent defines model for Consent.
type Consent struct {
	AcceptanceMethod *ConsentAcceptanceMethod `json:"acceptance_method,omitempty"`
	AcceptedAt       *time.Time               `json:"accepted_at,omitempty"`
	Id               *string                  `json:"id,omitempty"`
	IpAddress        *string                  `json:"ip_address"`
	LinkToken        *string                  `json:"link_token"`
	PolicySlug       *string                  `json:"policy_slug,omitempty"`
	PolicyVersion    *string                  `json:"policy_version,omitempty"`
	RevokedAt        *time.Time               `json:"revoked_at"`
	RevokedBy        *string                  `json:"revoked_by"`
	Subject          *string                  `json:"subject,omitempty"`
	TenantId         *string                  `json:"tenant_id,omitempty"`
	UserAgent        *string                  `json:"user_agent"`
}

// ConsentAcceptanceMethod defines model for Consent.AcceptanceMethod.
type ConsentAcceptanceMethod string

// ConsentLink defines model for ConsentLink.
type ConsentLink struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	CreatedBy *string    `json:"created_by,omitempty"`
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Policies  *[]string  `json:"policies,omitempty"`
	Subject   *string    `json:"subject,omitempty"`
	TenantId  *string    `json:"tenant_id,omitempty"`
	Token     *string    `json:"token,omitempty"`
	UsedAt    *time.Time `json:"used_at"`
}

// ConsentStatusResponse defines model for ConsentStatusResponse.
type ConsentStatusResponse struct {
	Statuses *[]PolicyConsentStatus `json:"statuses,omitempty"`
	Subject  *string                `json:"subject,omitempty"`
}

// ConsentsResponse defines model for ConsentsResponse.
type ConsentsResponse struct {
	Consents *[]Consent `json:"consents,omitempty"`
}

// CreateConsentRequest defines model for CreateConsentRequest.
type CreateConsentRequest struct {
	Policies []struct {
		Slug string `json:"slug"`

		// Version If not provided, uses the active version
		Version *string `json:"version,omitempty"`
	} `json:"policies"`
	Subject string `json:"subject"`
}

// CreateLinkRequest defines model for CreateLinkRequest.
type CreateLinkRequest struct {
	CreatedBy      string   `json:"created_by"`
	ExpiresInHours int      `json:"expires_in_hours"`
	Policies       []string `json:"policies"`
	Subject        string   `json:"subject"`
}

// CreateLinkResponse defines model for CreateLinkResponse.
type CreateLinkResponse struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
	Url       *string    `json:"url,omitempty"`
}

// CreatePolicyRequest defines model for CreatePolicyRequest.
type CreatePolicyRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *string `json:"error,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	CreatedAt   *time.Time       `json:"created_at,omitempty"`
	Description *string          `json:"description,omitempty"`
	Id          *string          `json:"id,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Slug        *string          `json:"slug,omitempty"`
	TenantId    *string          `json:"tenant_id,omitempty"`
	UpdatedAt   *time.Time       `json:"updated_at,omitempty"`
	Versions    *[]PolicyVersion `json:"versions,omitempty"`
}

// PolicyConsentStatus defines model for PolicyConsentStatus.
type PolicyConsentStatus struct {
	ActiveVersion *string `json:"active_version,omitempty"`

	// ConsentedVersion Version the subject consented to, null if missing
	ConsentedVersion *string                    `json:"consented_version"`
	Description      *string                    `json:"description,omitempty"`
	Name             *string                    `json:"name,omitempty"`
	Slug             *string                    `json:"slug,omitempty"`
	Status           *PolicyConsentStatusStatus `json:"status,omitempty"`
}

// PolicyConsentStatusStatus defines model for PolicyConsentStatus.Status.
type PolicyConsentStatusStatus string

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Policies *[]Policy `json:"policies,omitempty"`
}

// PolicyVersion defines model for PolicyVersion.
type PolicyVersion struct {
	ContentHtml     *string    `json:"content_html,omitempty"`
	ContentMarkdown *string    `json:"content_markdown,omitempty"`
	IsActive        *bool      `json:"is_active,omitempty"`
	PdfUrl          *string    `json:"pdf_url,omitempty"`
	PublishedAt     *time.Time `json:"published_at,omitempty"`

	// RequiresReAcceptance Whether upgrading to this version requires subjects to re-accept
	RequiresReAcceptance *bool   `json:"requires_re_acceptance,omitempty"`
	Version              *string `json:"version,omitempty"`
}

// PublicLinkInfo defines model for PublicLinkInfo.
type PublicLinkInfo struct {
	ExpiresAt  *time.Time          `json:"expires_at,omitempty"`
	Policies   *[]PublicPolicyInfo `json:"policies,omitempty"`
	Subject    *string             `json:"subject,omitempty"`
	TenantName *string             `json:"tenant_name"`
	Token      *string             `json:"token,omitempty"`
}

// PublicPolicyInfo defines model for PublicPolicyInfo.
type PublicPolicyInfo struct {
	ContentHtml     *string `json:"content_html,omitempty"`
	ContentMarkdown *string `json:"content_markdown,omitempty"`
	Description     *string `json:"description,omitempty"`
	Name            *string `json:"name,omitempty"`
	PdfUrl          *string `json:"pdf_url,omitempty"`
	Slug            *string `json:"slug,omitempty"`
	Version         *string `json:"version,omitempty"`
}

// RevokeConsentRequest defines model for RevokeConsentRequest.
type RevokeConsentRequest struct {
	RevokedBy string `json:"revoked_by"`
}

// SubjectConsentsResponse defines model for SubjectConsentsResponse.
type SubjectConsentsResponse struct {
	Consents *[]Consent `json:"consents,omitempty"`
	Subject  *string    `json:"subject,omitempty"`
}

// TenantID defines model for TenantID.
type TenantID = string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// GetConsentsParams defines parameters for GetConsents.
type GetConsentsParams struct {
	// Subject Subject identifier (external ID)
	Subject string `form:"subject" json:"subject"`

	// Policy Filter by specific policy slug
	Policy *string `form:"policy,omitempty" json:"policy,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateConsentParams defines parameters for CreateConsent.
type CreateConsentParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetConsentStatusParams defines parameters for GetConsentStatus.
type GetConsentStatusParams struct {
	// Subject Subject identifier (external ID)
	Subject string `form:"subject" json:"subject"`

	// Slugs Comma-separated list of policy slugs to check. If omitted, all active policies of the tenant are used.
	Slugs *string `form:"slugs,omitempty" json:"slugs,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// RevokeConsentParams defines parameters for RevokeConsent.
type RevokeConsentParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetConsentByIdParams defines parameters for GetConsentById.
type GetConsentByIdParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateLinkParams defines parameters for CreateLink.
type CreateLinkParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// DeleteLinkParams defines parameters for DeleteLink.
type DeleteLinkParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetLinkStatusParams defines parameters for GetLinkStatus.
type GetLinkStatusParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// Active Filter to only policies with active versions
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetPolicyParams defines parameters for GetPolicy.
type GetPolicyParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// AddPolicyVersionParams defines parameters for AddPolicyVersion.
type AddPolicyVersionParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateConsentJSONRequestBody defines body for CreateConsent for application/json ContentType.
type CreateConsentJSONRequestBody = CreateConsentRequest

// RevokeConsentJSONRequestBody defines body for RevokeConsent for application/json ContentType.
type RevokeConsentJSONRequestBody = RevokeConsentRequest

// CreateLinkJSONRequestBody defines body for CreateLink for application/json ContentType.
type CreateLinkJSONRequestBody = CreateLinkRequest

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyRequest

// AddPolicyVersionJSONRequestBody defines body for AddPolicyVersion for application/json ContentType.
type AddPolicyVersionJSONRequestBody = AddVersionRequest

// AcceptConsentJSONRequestBody defines body for AcceptConsent for application/json ContentType.
type AcceptConsentJSONRequestBody = AcceptConsentRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get consents for a subject
	// (GET /admin/consents)
	GetConsents(c *gin.Context, params GetConsentsParams)
	// Create consents (direct acceptance via tablet/operator)
	// (POST /admin/consents)
	CreateConsent(c *gin.Context, params CreateConsentParams)
	// Get consent status for a subject
	// (GET /admin/consents/status)
	GetConsentStatus(c *gin.Context, params GetConsentStatusParams)
	// Revoke a consent
	// (DELETE /admin/consents/{id})
	RevokeConsent(c *gin.Context, id string, params RevokeConsentParams)
	// Get consent by ID
	// (GET /admin/consents/{id})
	GetConsentById(c *gin.Context, id string, params GetConsentByIdParams)
	// Create a shareable consent link
	// (POST /admin/links)
	CreateLink(c *gin.Context, params CreateLinkParams)
	// Invalidate a consent link
	// (DELETE /admin/links/{token})
	DeleteLink(c *gin.Context, token string, params DeleteLinkParams)
	// Get link status
	// (GET /admin/links/{token})
	GetLinkStatus(c *gin.Context, token string, params GetLinkStatusParams)
	// List all policies
	// (GET /admin/policies)
	ListPolicies(c *gin.Context, params ListPoliciesParams)
	// Create a new policy
	// (POST /admin/policies)
	CreatePolicy(c *gin.Context, params CreatePolicyParams)
	// Get policy details
	// (GET /admin/policies/{slug})
	GetPolicy(c *gin.Context, slug string, params GetPolicyParams)
	// Add a new version to a policy
	// (POST /admin/policies/{slug}/versions)
	AddPolicyVersion(c *gin.Context, slug string, params AddPolicyVersionParams)
	// Get link info for consent acceptance
	// (GET /public/links/{token})
	GetPublicLinkInfo(c *gin.Context, token string)
	// Accept consents via link
	// (POST /public/links/{token}/accept)
	AcceptConsent(c *gin.Context, token string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetConsents operation middleware
func (siw *ServerInterfaceWrapper) GetConsents(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentsParams

	// ------------- Required query parameter "subject" -------------

	if paramValue := c.Query("subject"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument subject is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "subject", c.Request.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subject: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "policy" -------------

	err = runtime.BindQueryParameter("form", true, false, "policy", c.Request.URL.Query(), &params.Policy)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter policy: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsents(c, params)
}

// CreateConsent operation middleware
func (siw *ServerInterfaceWrapper) CreateConsent(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateConsentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateConsent(c, params)
}

// GetConsentStatus operation middleware
func (siw *ServerInterfaceWrapper) GetConsentStatus(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentStatusParams

	// ------------- Required query parameter "subject" -------------

	if paramValue := c.Query("subject"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument subject is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "subject", c.Request.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subject: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "slugs" -------------

	err = runtime.BindQueryParameter("form", true, false, "slugs", c.Request.URL.Query(), &params.Slugs)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slugs: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsentStatus(c, params)
}

// RevokeConsent operation middleware
func (siw *ServerInterfaceWrapper) RevokeConsent(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RevokeConsentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RevokeConsent(c, id, params)
}

// GetConsentById operation middleware
func (siw *ServerInterfaceWrapper) GetConsentById(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentByIdParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsentById(c, id, params)
}

// CreateLink operation middleware
func (siw *ServerInterfaceWrapper) CreateLink(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateLinkParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateLink(c, params)
}

// DeleteLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteLink(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteLinkParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteLink(c, token, params)
}

// GetLinkStatus operation middleware
func (siw *ServerInterfaceWrapper) GetLinkStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLinkStatusParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLinkStatus(c, token, params)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", c.Request.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter active: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c, params)
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePolicyParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreatePolicy(c, params)
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(c *gin.Context) {

	var err error

	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", c.Param("slug"), &slug, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slug: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPolicyParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPolicy(c, slug, params)
}

// AddPolicyVersion operation middleware
func (siw *ServerInterfaceWrapper) AddPolicyVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", c.Param("slug"), &slug, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slug: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AddPolicyVersionParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AddPolicyVersion(c, slug, params)
}

// GetPublicLinkInfo operation middleware
func (siw *ServerInterfaceWrapper) GetPublicLinkInfo(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPublicLinkInfo(c, token)
}

// AcceptConsent operation middleware
func (siw *ServerInterfaceWrapper) AcceptConsent(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AcceptConsent(c, token)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/admin/consents", wrapper.GetConsents)
	router.POST(options.BaseURL+"/admin/consents", wrapper.CreateConsent)
	router.GET(options.BaseURL+"/admin/consents/status", wrapper.GetConsentStatus)
	router.DELETE(options.BaseURL+"/admin/consents/:id", wrapper.RevokeConsent)
	router.GET(options.BaseURL+"/admin/consents/:id", wrapper.GetConsentById)
	router.POST(options.BaseURL+"/admin/links", wrapper.CreateLink)
	router.DELETE(options.BaseURL+"/admin/links/:token", wrapper.DeleteLink)
	router.GET(options.BaseURL+"/admin/links/:token", wrapper.GetLinkStatus)
	router.GET(options.BaseURL+"/admin/policies", wrapper.ListPolicies)
	router.POST(options.BaseURL+"/admin/policies", wrapper.CreatePolicy)
	router.GET(options.BaseURL+"/admin/policies/:slug", wrapper.GetPolicy)
	router.POST(options.BaseURL+"/admin/policies/:slug/versions", wrapper.AddPolicyVersion)
	router.GET(options.BaseURL+"/public/links/:token", wrapper.GetPublicLinkInfo)
	router.POST(options.BaseURL+"/public/links/:token/accept", wrapper.AcceptConsent)
}

type BadRequestJSONResponse ErrorResponse

type InternalServerErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type GetConsentsRequestObject struct {
	Params GetConsentsParams
}

type GetConsentsResponseObject interface {
	VisitGetConsentsResponse(w http.ResponseWriter) error
}

type GetConsents200JSONResponse SubjectConsentsResponse

func (response GetConsents200JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsents400JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsents404JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsents500JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsentRequestObject struct {
	Params CreateConsentParams
	Body   *CreateConsentJSONRequestBody
}

type CreateConsentResponseObject interface {
	VisitCreateConsentResponse(w http.ResponseWriter) error
}

type CreateConsent201JSONResponse ConsentsResponse

func (response CreateConsent201JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateConsent400JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateConsent404JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateConsent500JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatusRequestObject struct {
	Params GetConsentStatusParams
}

type GetConsentStatusResponseObject interface {
	VisitGetConsentStatusResponse(w http.ResponseWriter) error
}

type GetConsentStatus200JSONResponse ConsentStatusResponse

func (response GetConsentStatus200JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsentStatus400JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsentStatus404JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsentStatus500JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsentRequestObject struct {
	Id     string `json:"id"`
	Params RevokeConsentParams
	Body   *RevokeConsentJSONRequestBody
}

type RevokeConsentResponseObject interface {
	VisitRevokeConsentResponse(w http.ResponseWriter) error
}

type RevokeConsent200JSONResponse Consent

func (response RevokeConsent200JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response RevokeConsent404JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent409JSONResponse ErrorResponse

func (response RevokeConsent409JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response RevokeConsent500JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentByIdRequestObject struct {
	Id     string `json:"id"`
	Params GetConsentByIdParams
}

type GetConsentByIdResponseObject interface {
	VisitGetConsentByIdResponse(w http.ResponseWriter) error
}

type GetConsentById200JSONResponse Consent

func (response GetConsentById200JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsentById400JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsentById404JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsentById500JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateLinkRequestObject struct {
	Params CreateLinkParams
	Body   *CreateLinkJSONRequestBody
}

type CreateLinkResponseObject interface {
	VisitCreateLinkResponse(w http.ResponseWriter) error
}

type CreateLink201JSONResponse CreateLinkResponse

func (response CreateLink201JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateLink400JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateLink404JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateLink500JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLinkRequestObject struct {
	Token  string `json:"token"`
	Params DeleteLinkParams
}

type DeleteLinkResponseObject interface {
	VisitDeleteLinkResponse(w http.ResponseWriter) error
}

type DeleteLink204Response struct {
}

func (response DeleteLink204Response) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteLink404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteLink404JSONResponse) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLink500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteLink500JSONResponse) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatusRequestObject struct {
	Token  string `json:"token"`
	Params GetLinkStatusParams
}

type GetLinkStatusResponseObject interface {
	VisitGetLinkStatusResponse(w http.ResponseWriter) error
}

type GetLinkStatus200JSONResponse ConsentLink

func (response GetLinkStatus200JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus400JSONResponse struct{ BadRequestJSONResponse }

func (response GetLinkStatus400JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus404JSONResponse struct{ NotFoundJSONResponse }

func (response GetLinkStatus404JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetLinkStatus500JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPoliciesRequestObject struct {
	Params ListPoliciesParams
}

type ListPoliciesResponseObject interface {
	VisitListPoliciesResponse(w http.ResponseWriter) error
}

type ListPolicies200JSONResponse PolicyListResponse

func (response ListPolicies200JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPolicies400JSONResponse struct{ BadRequestJSONResponse }

func (response ListPolicies400JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListPolicies500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPolicies500JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicyRequestObject struct {
	Params CreatePolicyParams
	Body   *CreatePolicyJSONRequestBody
}

type CreatePolicyResponseObject interface {
	VisitCreatePolicyResponse(w http.ResponseWriter) error
}

type CreatePolicy201JSONResponse Policy

func (response CreatePolicy201JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy400JSONResponse struct{ BadRequestJSONResponse }

func (response CreatePolicy400JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy409JSONResponse ErrorResponse

func (response CreatePolicy409JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreatePolicy500JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicyRequestObject struct {
	Slug   string `json:"slug"`
	Params GetPolicyParams
}

type GetPolicyResponseObject interface {
	VisitGetPolicyResponse(w http.ResponseWriter) error
}

type GetPolicy200JSONResponse Policy

func (response GetPolicy200JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy400JSONResponse struct{ BadRequestJSONResponse }

func (response GetPolicy400JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy404JSONResponse struct{ NotFoundJSONResponse }

func (response GetPolicy404JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetPolicy500JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersionRequestObject struct {
	Slug   string `json:"slug"`
	Params AddPolicyVersionParams
	Body   *AddPolicyVersionJSONRequestBody
}

type AddPolicyVersionResponseObject interface {
	VisitAddPolicyVersionResponse(w http.ResponseWriter) error
}

type AddPolicyVersion201JSONResponse Policy

func (response AddPolicyVersion201JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion400JSONResponse struct{ BadRequestJSONResponse }

func (response AddPolicyVersion400JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion404JSONResponse struct{ NotFoundJSONResponse }

func (response AddPolicyVersion404JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion409JSONResponse ErrorResponse

func (response AddPolicyVersion409JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AddPolicyVersion500JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfoRequestObject struct {
	Token string `json:"token"`
}

type GetPublicLinkInfoResponseObject interface {
	VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error
}

type GetPublicLinkInfo200JSONResponse PublicLinkInfo

func (response GetPublicLinkInfo200JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo404JSONResponse struct{ NotFoundJSONResponse }

func (response GetPublicLinkInfo404JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo410JSONResponse ErrorResponse

func (response GetPublicLinkInfo410JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(410)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetPublicLinkInfo500JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsentRequestObject struct {
	Token string `json:"token"`
	Body  *AcceptConsentJSONRequestBody
}

type AcceptConsentResponseObject interface {
	VisitAcceptConsentResponse(w http.ResponseWriter) error
}

type AcceptConsent201JSONResponse ConsentsResponse

func (response AcceptConsent201JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent400JSONResponse struct{ BadRequestJSONResponse }

func (response AcceptConsent400JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response AcceptConsent404JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent410JSONResponse ErrorResponse

func (response AcceptConsent410JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(410)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AcceptConsent500JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get consents for a subject
	// (GET /admin/consents)
	GetConsents(ctx context.Context, request GetConsentsRequestObject) (GetConsentsResponseObject, error)
	// Create consents (direct acceptance via tablet/operator)
	// (POST /admin/consents)
	CreateConsent(ctx context.Context, request CreateConsentRequestObject) (CreateConsentResponseObject, error)
	// Get consent status for a subject
	// (GET /admin/consents/status)
	GetConsentStatus(ctx context.Context, request GetConsentStatusRequestObject) (GetConsentStatusResponseObject, error)
	// Revoke a consent
	// (DELETE /admin/consents/{id})
	RevokeConsent(ctx context.Context, request RevokeConsentRequestObject) (RevokeConsentResponseObject, error)
	// Get consent by ID
	// (GET /admin/consents/{id})
	GetConsentById(ctx context.Context, request GetConsentByIdRequestObject) (GetConsentByIdResponseObject, error)
	// Create a shareable consent link
	// (POST /admin/links)
	CreateLink(ctx context.Context, request CreateLinkRequestObject) (CreateLinkResponseObject, error)
	// Invalidate a consent link
	// (DELETE /admin/links/{token})
	DeleteLink(ctx context.Context, request DeleteLinkRequestObject) (DeleteLinkResponseObject, error)
	// Get link status
	// (GET /admin/links/{token})
	GetLinkStatus(ctx context.Context, request GetLinkStatusRequestObject) (GetLinkStatusResponseObject, error)
	// List all policies
	// (GET /admin/policies)
	ListPolicies(ctx context.Context, request ListPoliciesRequestObject) (ListPoliciesResponseObject, error)
	// Create a new policy
	// (POST /admin/policies)
	CreatePolicy(ctx context.Context, request CreatePolicyRequestObject) (CreatePolicyResponseObject, error)
	// Get policy details
	// (GET /admin/policies/{slug})
	GetPolicy(ctx context.Context, request GetPolicyRequestObject) (GetPolicyResponseObject, error)
	// Add a new version to a policy
	// (POST /admin/policies/{slug}/versions)
	AddPolicyVersion(ctx context.Context, request AddPolicyVersionRequestObject) (AddPolicyVersionResponseObject, error)
	// Get link info for consent acceptance
	// (GET /public/links/{token})
	GetPublicLinkInfo(ctx context.Context, request GetPublicLinkInfoRequestObject) (GetPublicLinkInfoResponseObject, error)
	// Accept consents via link
	// (POST /public/links/{token}/accept)
	AcceptConsent(ctx context.Context, request AcceptConsentRequestObject) (AcceptConsentResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetConsents operation middleware
func (sh *strictHandler) GetConsents(ctx *gin.Context, params GetConsentsParams) {
	var request GetConsentsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsents(ctx, request.(GetConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentsResponseObject); ok {
		if err := validResponse.VisitGetConsentsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateConsent operation middleware
func (sh *strictHandler) CreateConsent(ctx *gin.Context, params CreateConsentParams) {
	var request CreateConsentRequestObject

	request.Params = params

	var body CreateConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConsent(ctx, request.(CreateConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateConsentResponseObject); ok {
		if err := validResponse.VisitCreateConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConsentStatus operation middleware
func (sh *strictHandler) GetConsentStatus(ctx *gin.Context, params GetConsentStatusParams) {
	var request GetConsentStatusRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsentStatus(ctx, request.(GetConsentStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsentStatus")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentStatusResponseObject); ok {
		if err := validResponse.VisitGetConsentStatusResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RevokeConsent operation middleware
func (sh *strictHandler) RevokeConsent(ctx *gin.Context, id string, params RevokeConsentParams) {
	var request RevokeConsentRequestObject

	request.Id = id
	request.Params = params

	var body RevokeConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RevokeConsent(ctx, request.(RevokeConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RevokeConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RevokeConsentResponseObject); ok {
		if err := validResponse.VisitRevokeConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConsentById operation middleware
func (sh *strictHandler) GetConsentById(ctx *gin.Context, id string, params GetConsentByIdParams) {
	var request GetConsentByIdRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsentById(ctx, request.(GetConsentByIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsentById")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentByIdResponseObject); ok {
		if err := validResponse.VisitGetConsentByIdResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateLink operation middleware
func (sh *strictHandler) CreateLink(ctx *gin.Context, params CreateLinkParams) {
	var request CreateLinkRequestObject

	request.Params = params

	var body CreateLinkJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateLink(ctx, request.(CreateLinkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateLink")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateLinkResponseObject); ok {
		if err := validResponse.VisitCreateLinkResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteLink operation middleware
func (sh *strictHandler) DeleteLink(ctx *gin.Context, token string, params DeleteLinkParams) {
	var request DeleteLinkRequestObject

	request.Token = token
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteLink(ctx, request.(DeleteLinkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteLink")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteLinkResponseObject); ok {
		if err := validResponse.VisitDeleteLinkResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetLinkStatus operation middleware
func (sh *strictHandler) GetLinkStatus(ctx *gin.Context, token string, params GetLinkStatusParams) {
	var request GetLinkStatusRequestObject

	request.Token = token
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetLinkStatus(ctx, request.(GetLinkStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetLinkStatus")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetLinkStatusResponseObject); ok {
		if err := validResponse.VisitGetLinkStatusResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPolicies operation middleware
func (sh *strictHandler) ListPolicies(ctx *gin.Context, params ListPoliciesParams) {
	var request ListPoliciesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListPolicies(ctx, request.(ListPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPolicies")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListPoliciesResponseObject); ok {
		if err := validResponse.VisitListPoliciesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePolicy operation middleware
func (sh *strictHandler) CreatePolicy(ctx *gin.Context, params CreatePolicyParams) {
	var request CreatePolicyRequestObject

	request.Params = params

	var body CreatePolicyJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePolicy(ctx, request.(CreatePolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreatePolicyResponseObject); ok {
		if err := validResponse.VisitCreatePolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPolicy operation middleware
func (sh *strictHandler) GetPolicy(ctx *gin.Context, slug string, params GetPolicyParams) {
	var request GetPolicyRequestObject

	request.Slug = slug
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPolicy(ctx, request.(GetPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPolicyResponseObject); ok {
		if err := validResponse.VisitGetPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddPolicyVersion operation middleware
func (sh *strictHandler) AddPolicyVersion(ctx *gin.Context, slug string, params AddPolicyVersionParams) {
	var request AddPolicyVersionRequestObject

	request.Slug = slug
	request.Params = params

	var body AddPolicyVersionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AddPolicyVersion(ctx, request.(AddPolicyVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddPolicyVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AddPolicyVersionResponseObject); ok {
		if err := validResponse.VisitAddPolicyVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPublicLinkInfo operation middleware
func (sh *strictHandler) GetPublicLinkInfo(ctx *gin.Context, token string) {
	var request GetPublicLinkInfoRequestObject

	request.Token = token

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPublicLinkInfo(ctx, request.(GetPublicLinkInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPublicLinkInfo")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPublicLinkInfoResponseObject); ok {
		if err := validResponse.VisitGetPublicLinkInfoResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AcceptConsent operation middleware
func (sh *strictHandler) AcceptConsent(ctx *gin.Context, token string) {
	var request AcceptConsentRequestObject

	request.Token = token

	var body AcceptConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AcceptConsent(ctx, request.(AcceptConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AcceptConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AcceptConsentResponseObject); ok {
		if err := validResponse.VisitAcceptConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
