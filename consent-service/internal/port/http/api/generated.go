// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// Defines values for ConsentAcceptanceMethod.
const (
	Direct ConsentAcceptanceMethod = "direct"
	Link   ConsentAcceptanceMethod = "link"
)

// Defines values for PolicyConsentStatusStatus.
const (
	Accepted PolicyConsentStatusStatus = "accepted"
	Missing  PolicyConsentStatusStatus = "missing"
	Outdated PolicyConsentStatusStatus = "outdated"
)

// AcceptConsentRequest defines model for AcceptConsentRequest.
type AcceptConsentRequest struct {
	AcceptedPolicies []string `json:"accepted_policies"`
}

// AddVersionRequest defines model for AddVersionRequest.
type AddVersionRequest struct {
	ContentHtml     *string `json:"content_html,omitempty"`
	ContentMarkdown *string `json:"content_markdown,omitempty"`
	IsActive        *bool   `json:"is_active,omitempty"`
	PdfUrl          *string `json:"pdf_url,omitempty"`

	// RequiresReAcceptance Whether this version requires subjects to re-accept their consent
	RequiresReAcceptance *bool  `json:"requires_re_acceptance,omitempty"`
	Version              string `json:"version"`
}

// Consent defines model for Consent.
type Consent struct {
	AcceptanceMethod *ConsentAcceptanceMethod `json:"acceptance_method,omitempty"`
	AcceptedAt       *time.Time               `json:"accepted_at,omitempty"`
	Id               *string                  `json:"id,omitempty"`
	LinkToken        *string                  `json:"link_token"`
	PolicySlug       *string                  `json:"policy_slug,omitempty"`
	PolicyVersion    *string                  `json:"policy_version,omitempty"`
	RevokedAt        *time.Time               `json:"revoked_at"`
	RevokedBy        *string                  `json:"revoked_by"`
	Subject          *string                  `json:"subject,omitempty"`
	TenantId         *string                  `json:"tenant_id,omitempty"`
}

// ConsentAcceptanceMethod defines model for Consent.AcceptanceMethod.
type ConsentAcceptanceMethod string

// ConsentLink defines model for ConsentLink.
type ConsentLink struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	CreatedBy *string    `json:"created_by,omitempty"`
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Policies  *[]string  `json:"policies,omitempty"`
	Subject   *string    `json:"subject,omitempty"`
	TenantId  *string    `json:"tenant_id,omitempty"`
	Token     *string    `json:"token,omitempty"`
	UsedAt    *time.Time `json:"used_at"`
}

// ConsentStatusResponse defines model for ConsentStatusResponse.
type ConsentStatusResponse struct {
	Statuses *[]PolicyConsentStatus `json:"statuses,omitempty"`
	Subject  *string                `json:"subject,omitempty"`
}

// ConsentsResponse defines model for ConsentsResponse.
type ConsentsResponse struct {
	Consents *[]Consent `json:"consents,omitempty"`
}

// CreateConsentRequest defines model for CreateConsentRequest.
type CreateConsentRequest struct {
	Policies []struct {
		Slug string `json:"slug"`

		// Version If not provided, uses the active version
		Version *string `json:"version,omitempty"`
	} `json:"policies"`
	Subject string `json:"subject"`
}

// CreateLinkRequest defines model for CreateLinkRequest.
type CreateLinkRequest struct {
	CreatedBy      string   `json:"created_by"`
	ExpiresInHours int      `json:"expires_in_hours"`
	Policies       []string `json:"policies"`
	Subject        string   `json:"subject"`
}

// CreateLinkResponse defines model for CreateLinkResponse.
type CreateLinkResponse struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
	Url       *string    `json:"url,omitempty"`
}

// CreatePolicyRequest defines model for CreatePolicyRequest.
type CreatePolicyRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	Slug        string  `json:"slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *string `json:"error,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	CreatedAt   *time.Time       `json:"created_at,omitempty"`
	Description *string          `json:"description,omitempty"`
	Id          *string          `json:"id,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Slug        *string          `json:"slug,omitempty"`
	TenantId    *string          `json:"tenant_id,omitempty"`
	UpdatedAt   *time.Time       `json:"updated_at,omitempty"`
	Versions    *[]PolicyVersion `json:"versions,omitempty"`
}

// PolicyConsentStatus defines model for PolicyConsentStatus.
type PolicyConsentStatus struct {
	ActiveVersion *string `json:"active_version,omitempty"`

	// ConsentedVersion Version the subject consented to, null if missing
	ConsentedVersion *string                    `json:"consented_version"`
	Description      *string                    `json:"description,omitempty"`
	Name             *string                    `json:"name,omitempty"`
	Slug             *string                    `json:"slug,omitempty"`
	Status           *PolicyConsentStatusStatus `json:"status,omitempty"`
}

// PolicyConsentStatusStatus defines model for PolicyConsentStatus.Status.
type PolicyConsentStatusStatus string

// PolicyListResponse defines model for PolicyListResponse.
type PolicyListResponse struct {
	Policies *[]Policy `json:"policies,omitempty"`
}

// PolicyVersion defines model for PolicyVersion.
type PolicyVersion struct {
	ContentHtml     *string    `json:"content_html,omitempty"`
	ContentMarkdown *string    `json:"content_markdown,omitempty"`
	IsActive        *bool      `json:"is_active,omitempty"`
	PdfUrl          *string    `json:"pdf_url,omitempty"`
	PublishedAt     *time.Time `json:"published_at,omitempty"`

	// RequiresReAcceptance Whether upgrading to this version requires subjects to re-accept
	RequiresReAcceptance *bool   `json:"requires_re_acceptance,omitempty"`
	Version              *string `json:"version,omitempty"`
}

// PublicLinkInfo defines model for PublicLinkInfo.
type PublicLinkInfo struct {
	ExpiresAt *time.Time          `json:"expires_at,omitempty"`
	Policies  *[]PublicPolicyInfo `json:"policies,omitempty"`
	Subject   *string             `json:"subject,omitempty"`
	Token     *string             `json:"token,omitempty"`
}

// PublicPolicyInfo defines model for PublicPolicyInfo.
type PublicPolicyInfo struct {
	ContentHtml     *string `json:"content_html,omitempty"`
	ContentMarkdown *string `json:"content_markdown,omitempty"`
	Description     *string `json:"description,omitempty"`
	Name            *string `json:"name,omitempty"`
	PdfUrl          *string `json:"pdf_url,omitempty"`
	Slug            *string `json:"slug,omitempty"`
	Version         *string `json:"version,omitempty"`
}

// RevokeConsentRequest defines model for RevokeConsentRequest.
type RevokeConsentRequest struct {
	RevokedBy string `json:"revoked_by"`
}

// SubjectConsentsResponse defines model for SubjectConsentsResponse.
type SubjectConsentsResponse struct {
	Consents *[]Consent `json:"consents,omitempty"`
	Subject  *string    `json:"subject,omitempty"`
}

// TenantID defines model for TenantID.
type TenantID = string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// GetConsentsParams defines parameters for GetConsents.
type GetConsentsParams struct {
	// Subject Subject identifier (external ID)
	Subject string `form:"subject" json:"subject"`

	// Policy Filter by specific policy slug
	Policy *string `form:"policy,omitempty" json:"policy,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateConsentParams defines parameters for CreateConsent.
type CreateConsentParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetConsentStatusParams defines parameters for GetConsentStatus.
type GetConsentStatusParams struct {
	// Subject Subject identifier (external ID)
	Subject string `form:"subject" json:"subject"`

	// Slugs Comma-separated list of policy slugs to check. If omitted, all active policies of the tenant are used.
	Slugs *string `form:"slugs,omitempty" json:"slugs,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// RevokeConsentParams defines parameters for RevokeConsent.
type RevokeConsentParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetConsentByIdParams defines parameters for GetConsentById.
type GetConsentByIdParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateLinkParams defines parameters for CreateLink.
type CreateLinkParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// DeleteLinkParams defines parameters for DeleteLink.
type DeleteLinkParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetLinkStatusParams defines parameters for GetLinkStatus.
type GetLinkStatusParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// Active Filter to only policies with active versions
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreatePolicyParams defines parameters for CreatePolicy.
type CreatePolicyParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// GetPolicyParams defines parameters for GetPolicy.
type GetPolicyParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// AddPolicyVersionParams defines parameters for AddPolicyVersion.
type AddPolicyVersionParams struct {
	// XTenantID Tenant identifier for multi-tenancy
	XTenantID TenantID `json:"X-Tenant-ID"`
}

// CreateConsentJSONRequestBody defines body for CreateConsent for application/json ContentType.
type CreateConsentJSONRequestBody = CreateConsentRequest

// RevokeConsentJSONRequestBody defines body for RevokeConsent for application/json ContentType.
type RevokeConsentJSONRequestBody = RevokeConsentRequest

// CreateLinkJSONRequestBody defines body for CreateLink for application/json ContentType.
type CreateLinkJSONRequestBody = CreateLinkRequest

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody = CreatePolicyRequest

// AddPolicyVersionJSONRequestBody defines body for AddPolicyVersion for application/json ContentType.
type AddPolicyVersionJSONRequestBody = AddVersionRequest

// AcceptConsentJSONRequestBody defines body for AcceptConsent for application/json ContentType.
type AcceptConsentJSONRequestBody = AcceptConsentRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get consents for a subject
	// (GET /admin/consents)
	GetConsents(c *gin.Context, params GetConsentsParams)
	// Create consents (direct acceptance via tablet/operator)
	// (POST /admin/consents)
	CreateConsent(c *gin.Context, params CreateConsentParams)
	// Get consent status for a subject
	// (GET /admin/consents/status)
	GetConsentStatus(c *gin.Context, params GetConsentStatusParams)
	// Revoke a consent
	// (DELETE /admin/consents/{id})
	RevokeConsent(c *gin.Context, id string, params RevokeConsentParams)
	// Get consent by ID
	// (GET /admin/consents/{id})
	GetConsentById(c *gin.Context, id string, params GetConsentByIdParams)
	// Create a shareable consent link
	// (POST /admin/links)
	CreateLink(c *gin.Context, params CreateLinkParams)
	// Invalidate a consent link
	// (DELETE /admin/links/{token})
	DeleteLink(c *gin.Context, token string, params DeleteLinkParams)
	// Get link status
	// (GET /admin/links/{token})
	GetLinkStatus(c *gin.Context, token string, params GetLinkStatusParams)
	// List all policies
	// (GET /admin/policies)
	ListPolicies(c *gin.Context, params ListPoliciesParams)
	// Create a new policy
	// (POST /admin/policies)
	CreatePolicy(c *gin.Context, params CreatePolicyParams)
	// Get policy details
	// (GET /admin/policies/{slug})
	GetPolicy(c *gin.Context, slug string, params GetPolicyParams)
	// Add a new version to a policy
	// (POST /admin/policies/{slug}/versions)
	AddPolicyVersion(c *gin.Context, slug string, params AddPolicyVersionParams)
	// Get link info for consent acceptance
	// (GET /public/links/{token})
	GetPublicLinkInfo(c *gin.Context, token string)
	// Accept consents via link
	// (POST /public/links/{token}/accept)
	AcceptConsent(c *gin.Context, token string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetConsents operation middleware
func (siw *ServerInterfaceWrapper) GetConsents(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentsParams

	// ------------- Required query parameter "subject" -------------

	if paramValue := c.Query("subject"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument subject is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "subject", c.Request.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subject: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "policy" -------------

	err = runtime.BindQueryParameter("form", true, false, "policy", c.Request.URL.Query(), &params.Policy)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter policy: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsents(c, params)
}

// CreateConsent operation middleware
func (siw *ServerInterfaceWrapper) CreateConsent(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateConsentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateConsent(c, params)
}

// GetConsentStatus operation middleware
func (siw *ServerInterfaceWrapper) GetConsentStatus(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentStatusParams

	// ------------- Required query parameter "subject" -------------

	if paramValue := c.Query("subject"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument subject is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "subject", c.Request.URL.Query(), &params.Subject)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subject: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "slugs" -------------

	err = runtime.BindQueryParameter("form", true, false, "slugs", c.Request.URL.Query(), &params.Slugs)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slugs: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsentStatus(c, params)
}

// RevokeConsent operation middleware
func (siw *ServerInterfaceWrapper) RevokeConsent(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RevokeConsentParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RevokeConsent(c, id, params)
}

// GetConsentById operation middleware
func (siw *ServerInterfaceWrapper) GetConsentById(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConsentByIdParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetConsentById(c, id, params)
}

// CreateLink operation middleware
func (siw *ServerInterfaceWrapper) CreateLink(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateLinkParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateLink(c, params)
}

// DeleteLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteLink(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteLinkParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteLink(c, token, params)
}

// GetLinkStatus operation middleware
func (siw *ServerInterfaceWrapper) GetLinkStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLinkStatusParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLinkStatus(c, token, params)
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", c.Request.URL.Query(), &params.Active)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter active: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListPolicies(c, params)
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePolicyParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreatePolicy(c, params)
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(c *gin.Context) {

	var err error

	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", c.Param("slug"), &slug, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slug: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPolicyParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPolicy(c, slug, params)
}

// AddPolicyVersion operation middleware
func (siw *ServerInterfaceWrapper) AddPolicyVersion(c *gin.Context) {

	var err error

	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", c.Param("slug"), &slug, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter slug: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AddPolicyVersionParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Tenant-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Tenant-ID")]; found {
		var XTenantID TenantID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Tenant-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Tenant-ID", valueList[0], &XTenantID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Tenant-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XTenantID = XTenantID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Tenant-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AddPolicyVersion(c, slug, params)
}

// GetPublicLinkInfo operation middleware
func (siw *ServerInterfaceWrapper) GetPublicLinkInfo(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPublicLinkInfo(c, token)
}

// AcceptConsent operation middleware
func (siw *ServerInterfaceWrapper) AcceptConsent(c *gin.Context) {

	var err error

	// ------------- Path parameter "token" -------------
	var token string

	err = runtime.BindStyledParameterWithOptions("simple", "token", c.Param("token"), &token, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AcceptConsent(c, token)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/admin/consents", wrapper.GetConsents)
	router.POST(options.BaseURL+"/admin/consents", wrapper.CreateConsent)
	router.GET(options.BaseURL+"/admin/consents/status", wrapper.GetConsentStatus)
	router.DELETE(options.BaseURL+"/admin/consents/:id", wrapper.RevokeConsent)
	router.GET(options.BaseURL+"/admin/consents/:id", wrapper.GetConsentById)
	router.POST(options.BaseURL+"/admin/links", wrapper.CreateLink)
	router.DELETE(options.BaseURL+"/admin/links/:token", wrapper.DeleteLink)
	router.GET(options.BaseURL+"/admin/links/:token", wrapper.GetLinkStatus)
	router.GET(options.BaseURL+"/admin/policies", wrapper.ListPolicies)
	router.POST(options.BaseURL+"/admin/policies", wrapper.CreatePolicy)
	router.GET(options.BaseURL+"/admin/policies/:slug", wrapper.GetPolicy)
	router.POST(options.BaseURL+"/admin/policies/:slug/versions", wrapper.AddPolicyVersion)
	router.GET(options.BaseURL+"/public/links/:token", wrapper.GetPublicLinkInfo)
	router.POST(options.BaseURL+"/public/links/:token/accept", wrapper.AcceptConsent)
}

type BadRequestJSONResponse ErrorResponse

type InternalServerErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type GetConsentsRequestObject struct {
	Params GetConsentsParams
}

type GetConsentsResponseObject interface {
	VisitGetConsentsResponse(w http.ResponseWriter) error
}

type GetConsents200JSONResponse SubjectConsentsResponse

func (response GetConsents200JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsents400JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsents404JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsents500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsents500JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsentRequestObject struct {
	Params CreateConsentParams
	Body   *CreateConsentJSONRequestBody
}

type CreateConsentResponseObject interface {
	VisitCreateConsentResponse(w http.ResponseWriter) error
}

type CreateConsent201JSONResponse ConsentsResponse

func (response CreateConsent201JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateConsent400JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateConsent404JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateConsent500JSONResponse) VisitCreateConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatusRequestObject struct {
	Params GetConsentStatusParams
}

type GetConsentStatusResponseObject interface {
	VisitGetConsentStatusResponse(w http.ResponseWriter) error
}

type GetConsentStatus200JSONResponse ConsentStatusResponse

func (response GetConsentStatus200JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsentStatus400JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsentStatus404JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentStatus500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsentStatus500JSONResponse) VisitGetConsentStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsentRequestObject struct {
	Id     string `json:"id"`
	Params RevokeConsentParams
	Body   *RevokeConsentJSONRequestBody
}

type RevokeConsentResponseObject interface {
	VisitRevokeConsentResponse(w http.ResponseWriter) error
}

type RevokeConsent200JSONResponse Consent

func (response RevokeConsent200JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response RevokeConsent404JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent409JSONResponse ErrorResponse

func (response RevokeConsent409JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type RevokeConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response RevokeConsent500JSONResponse) VisitRevokeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentByIdRequestObject struct {
	Id     string `json:"id"`
	Params GetConsentByIdParams
}

type GetConsentByIdResponseObject interface {
	VisitGetConsentByIdResponse(w http.ResponseWriter) error
}

type GetConsentById200JSONResponse Consent

func (response GetConsentById200JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById400JSONResponse struct{ BadRequestJSONResponse }

func (response GetConsentById400JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById404JSONResponse struct{ NotFoundJSONResponse }

func (response GetConsentById404JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetConsentById500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetConsentById500JSONResponse) VisitGetConsentByIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateLinkRequestObject struct {
	Params CreateLinkParams
	Body   *CreateLinkJSONRequestBody
}

type CreateLinkResponseObject interface {
	VisitCreateLinkResponse(w http.ResponseWriter) error
}

type CreateLink201JSONResponse CreateLinkResponse

func (response CreateLink201JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateLink400JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink404JSONResponse struct{ NotFoundJSONResponse }

func (response CreateLink404JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateLink500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreateLink500JSONResponse) VisitCreateLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLinkRequestObject struct {
	Token  string `json:"token"`
	Params DeleteLinkParams
}

type DeleteLinkResponseObject interface {
	VisitDeleteLinkResponse(w http.ResponseWriter) error
}

type DeleteLink204Response struct {
}

func (response DeleteLink204Response) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteLink404JSONResponse struct{ NotFoundJSONResponse }

func (response DeleteLink404JSONResponse) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteLink500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response DeleteLink500JSONResponse) VisitDeleteLinkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatusRequestObject struct {
	Token  string `json:"token"`
	Params GetLinkStatusParams
}

type GetLinkStatusResponseObject interface {
	VisitGetLinkStatusResponse(w http.ResponseWriter) error
}

type GetLinkStatus200JSONResponse ConsentLink

func (response GetLinkStatus200JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus400JSONResponse struct{ BadRequestJSONResponse }

func (response GetLinkStatus400JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus404JSONResponse struct{ NotFoundJSONResponse }

func (response GetLinkStatus404JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetLinkStatus500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetLinkStatus500JSONResponse) VisitGetLinkStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListPoliciesRequestObject struct {
	Params ListPoliciesParams
}

type ListPoliciesResponseObject interface {
	VisitListPoliciesResponse(w http.ResponseWriter) error
}

type ListPolicies200JSONResponse PolicyListResponse

func (response ListPolicies200JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPolicies400JSONResponse struct{ BadRequestJSONResponse }

func (response ListPolicies400JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListPolicies500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response ListPolicies500JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicyRequestObject struct {
	Params CreatePolicyParams
	Body   *CreatePolicyJSONRequestBody
}

type CreatePolicyResponseObject interface {
	VisitCreatePolicyResponse(w http.ResponseWriter) error
}

type CreatePolicy201JSONResponse Policy

func (response CreatePolicy201JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy400JSONResponse struct{ BadRequestJSONResponse }

func (response CreatePolicy400JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy409JSONResponse ErrorResponse

func (response CreatePolicy409JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type CreatePolicy500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response CreatePolicy500JSONResponse) VisitCreatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicyRequestObject struct {
	Slug   string `json:"slug"`
	Params GetPolicyParams
}

type GetPolicyResponseObject interface {
	VisitGetPolicyResponse(w http.ResponseWriter) error
}

type GetPolicy200JSONResponse Policy

func (response GetPolicy200JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy400JSONResponse struct{ BadRequestJSONResponse }

func (response GetPolicy400JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy404JSONResponse struct{ NotFoundJSONResponse }

func (response GetPolicy404JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetPolicy500JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersionRequestObject struct {
	Slug   string `json:"slug"`
	Params AddPolicyVersionParams
	Body   *AddPolicyVersionJSONRequestBody
}

type AddPolicyVersionResponseObject interface {
	VisitAddPolicyVersionResponse(w http.ResponseWriter) error
}

type AddPolicyVersion201JSONResponse Policy

func (response AddPolicyVersion201JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion400JSONResponse struct{ BadRequestJSONResponse }

func (response AddPolicyVersion400JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion404JSONResponse struct{ NotFoundJSONResponse }

func (response AddPolicyVersion404JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion409JSONResponse ErrorResponse

func (response AddPolicyVersion409JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type AddPolicyVersion500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AddPolicyVersion500JSONResponse) VisitAddPolicyVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfoRequestObject struct {
	Token string `json:"token"`
}

type GetPublicLinkInfoResponseObject interface {
	VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error
}

type GetPublicLinkInfo200JSONResponse PublicLinkInfo

func (response GetPublicLinkInfo200JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo404JSONResponse struct{ NotFoundJSONResponse }

func (response GetPublicLinkInfo404JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo410JSONResponse ErrorResponse

func (response GetPublicLinkInfo410JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(410)

	return json.NewEncoder(w).Encode(response)
}

type GetPublicLinkInfo500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response GetPublicLinkInfo500JSONResponse) VisitGetPublicLinkInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsentRequestObject struct {
	Token string `json:"token"`
	Body  *AcceptConsentJSONRequestBody
}

type AcceptConsentResponseObject interface {
	VisitAcceptConsentResponse(w http.ResponseWriter) error
}

type AcceptConsent201JSONResponse ConsentsResponse

func (response AcceptConsent201JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent400JSONResponse struct{ BadRequestJSONResponse }

func (response AcceptConsent400JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent404JSONResponse struct{ NotFoundJSONResponse }

func (response AcceptConsent404JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent410JSONResponse ErrorResponse

func (response AcceptConsent410JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(410)

	return json.NewEncoder(w).Encode(response)
}

type AcceptConsent500JSONResponse struct {
	InternalServerErrorJSONResponse
}

func (response AcceptConsent500JSONResponse) VisitAcceptConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get consents for a subject
	// (GET /admin/consents)
	GetConsents(ctx context.Context, request GetConsentsRequestObject) (GetConsentsResponseObject, error)
	// Create consents (direct acceptance via tablet/operator)
	// (POST /admin/consents)
	CreateConsent(ctx context.Context, request CreateConsentRequestObject) (CreateConsentResponseObject, error)
	// Get consent status for a subject
	// (GET /admin/consents/status)
	GetConsentStatus(ctx context.Context, request GetConsentStatusRequestObject) (GetConsentStatusResponseObject, error)
	// Revoke a consent
	// (DELETE /admin/consents/{id})
	RevokeConsent(ctx context.Context, request RevokeConsentRequestObject) (RevokeConsentResponseObject, error)
	// Get consent by ID
	// (GET /admin/consents/{id})
	GetConsentById(ctx context.Context, request GetConsentByIdRequestObject) (GetConsentByIdResponseObject, error)
	// Create a shareable consent link
	// (POST /admin/links)
	CreateLink(ctx context.Context, request CreateLinkRequestObject) (CreateLinkResponseObject, error)
	// Invalidate a consent link
	// (DELETE /admin/links/{token})
	DeleteLink(ctx context.Context, request DeleteLinkRequestObject) (DeleteLinkResponseObject, error)
	// Get link status
	// (GET /admin/links/{token})
	GetLinkStatus(ctx context.Context, request GetLinkStatusRequestObject) (GetLinkStatusResponseObject, error)
	// List all policies
	// (GET /admin/policies)
	ListPolicies(ctx context.Context, request ListPoliciesRequestObject) (ListPoliciesResponseObject, error)
	// Create a new policy
	// (POST /admin/policies)
	CreatePolicy(ctx context.Context, request CreatePolicyRequestObject) (CreatePolicyResponseObject, error)
	// Get policy details
	// (GET /admin/policies/{slug})
	GetPolicy(ctx context.Context, request GetPolicyRequestObject) (GetPolicyResponseObject, error)
	// Add a new version to a policy
	// (POST /admin/policies/{slug}/versions)
	AddPolicyVersion(ctx context.Context, request AddPolicyVersionRequestObject) (AddPolicyVersionResponseObject, error)
	// Get link info for consent acceptance
	// (GET /public/links/{token})
	GetPublicLinkInfo(ctx context.Context, request GetPublicLinkInfoRequestObject) (GetPublicLinkInfoResponseObject, error)
	// Accept consents via link
	// (POST /public/links/{token}/accept)
	AcceptConsent(ctx context.Context, request AcceptConsentRequestObject) (AcceptConsentResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetConsents operation middleware
func (sh *strictHandler) GetConsents(ctx *gin.Context, params GetConsentsParams) {
	var request GetConsentsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsents(ctx, request.(GetConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsents")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentsResponseObject); ok {
		if err := validResponse.VisitGetConsentsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateConsent operation middleware
func (sh *strictHandler) CreateConsent(ctx *gin.Context, params CreateConsentParams) {
	var request CreateConsentRequestObject

	request.Params = params

	var body CreateConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConsent(ctx, request.(CreateConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateConsentResponseObject); ok {
		if err := validResponse.VisitCreateConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConsentStatus operation middleware
func (sh *strictHandler) GetConsentStatus(ctx *gin.Context, params GetConsentStatusParams) {
	var request GetConsentStatusRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsentStatus(ctx, request.(GetConsentStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsentStatus")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentStatusResponseObject); ok {
		if err := validResponse.VisitGetConsentStatusResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RevokeConsent operation middleware
func (sh *strictHandler) RevokeConsent(ctx *gin.Context, id string, params RevokeConsentParams) {
	var request RevokeConsentRequestObject

	request.Id = id
	request.Params = params

	var body RevokeConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RevokeConsent(ctx, request.(RevokeConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RevokeConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RevokeConsentResponseObject); ok {
		if err := validResponse.VisitRevokeConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetConsentById operation middleware
func (sh *strictHandler) GetConsentById(ctx *gin.Context, id string, params GetConsentByIdParams) {
	var request GetConsentByIdRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConsentById(ctx, request.(GetConsentByIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConsentById")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetConsentByIdResponseObject); ok {
		if err := validResponse.VisitGetConsentByIdResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateLink operation middleware
func (sh *strictHandler) CreateLink(ctx *gin.Context, params CreateLinkParams) {
	var request CreateLinkRequestObject

	request.Params = params

	var body CreateLinkJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateLink(ctx, request.(CreateLinkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateLink")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateLinkResponseObject); ok {
		if err := validResponse.VisitCreateLinkResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteLink operation middleware
func (sh *strictHandler) DeleteLink(ctx *gin.Context, token string, params DeleteLinkParams) {
	var request DeleteLinkRequestObject

	request.Token = token
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteLink(ctx, request.(DeleteLinkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteLink")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteLinkResponseObject); ok {
		if err := validResponse.VisitDeleteLinkResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetLinkStatus operation middleware
func (sh *strictHandler) GetLinkStatus(ctx *gin.Context, token string, params GetLinkStatusParams) {
	var request GetLinkStatusRequestObject

	request.Token = token
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetLinkStatus(ctx, request.(GetLinkStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetLinkStatus")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetLinkStatusResponseObject); ok {
		if err := validResponse.VisitGetLinkStatusResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPolicies operation middleware
func (sh *strictHandler) ListPolicies(ctx *gin.Context, params ListPoliciesParams) {
	var request ListPoliciesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListPolicies(ctx, request.(ListPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPolicies")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListPoliciesResponseObject); ok {
		if err := validResponse.VisitListPoliciesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePolicy operation middleware
func (sh *strictHandler) CreatePolicy(ctx *gin.Context, params CreatePolicyParams) {
	var request CreatePolicyRequestObject

	request.Params = params

	var body CreatePolicyJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePolicy(ctx, request.(CreatePolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreatePolicyResponseObject); ok {
		if err := validResponse.VisitCreatePolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPolicy operation middleware
func (sh *strictHandler) GetPolicy(ctx *gin.Context, slug string, params GetPolicyParams) {
	var request GetPolicyRequestObject

	request.Slug = slug
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPolicy(ctx, request.(GetPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPolicyResponseObject); ok {
		if err := validResponse.VisitGetPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AddPolicyVersion operation middleware
func (sh *strictHandler) AddPolicyVersion(ctx *gin.Context, slug string, params AddPolicyVersionParams) {
	var request AddPolicyVersionRequestObject

	request.Slug = slug
	request.Params = params

	var body AddPolicyVersionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AddPolicyVersion(ctx, request.(AddPolicyVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddPolicyVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AddPolicyVersionResponseObject); ok {
		if err := validResponse.VisitAddPolicyVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPublicLinkInfo operation middleware
func (sh *strictHandler) GetPublicLinkInfo(ctx *gin.Context, token string) {
	var request GetPublicLinkInfoRequestObject

	request.Token = token

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPublicLinkInfo(ctx, request.(GetPublicLinkInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPublicLinkInfo")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetPublicLinkInfoResponseObject); ok {
		if err := validResponse.VisitGetPublicLinkInfoResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// AcceptConsent operation middleware
func (sh *strictHandler) AcceptConsent(ctx *gin.Context, token string) {
	var request AcceptConsentRequestObject

	request.Token = token

	var body AcceptConsentJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AcceptConsent(ctx, request.(AcceptConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AcceptConsent")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(AcceptConsentResponseObject); ok {
		if err := validResponse.VisitAcceptConsentResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
